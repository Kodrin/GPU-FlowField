#pragma kernel FlowField
#pragma kernel Particles

#define X_THREAD_COUNT 1024
#define Y_THREAD_COUNT 1
#define Z_THREAD_COUNT 1

#include "DataStructs.cginc"
#include "Voronoi3D.cginc"

float3 _BoundsDimensions;
float3 _BoundsPosition;
uint _XCellCount;
uint _YCellCount;
uint _ZCellCount;

RWStructuredBuffer<FlowFieldPointData> _FlowFieldPointBuffer;
RWStructuredBuffer<ParticleData> _ParticleBuffer;

// RONJA TUTORIALS REFERENCE 
float3 voronoiNoise(float3 value){
    float3 baseCell = floor(value);

    //first pass to find the closest cell
    float minDistToCell = 10;
    float3 toClosestCell;
    float3 closestCell;
    [unroll]
    for(int x1=-1; x1<=1; x1++){
        [unroll]
        for(int y1=-1; y1<=1; y1++){
            [unroll]
            for(int z1=-1; z1<=1; z1++){
                float3 cell = baseCell + float3(x1, y1, z1);
                float3 cellPosition = cell + rand3dTo3d(cell);
                float3 toCell = cellPosition - value;
                float distToCell = length(toCell);
                if(distToCell < minDistToCell){
                    minDistToCell = distToCell;
                    closestCell = cell;
                    toClosestCell = toCell;
                }
            }
        }
    }
    
    //second pass to find the distance to the closest edge
    float minEdgeDistance = 10;
    [unroll]
    for(int x2=-1; x2<=1; x2++){
        [unroll]
        for(int y2=-1; y2<=1; y2++){
            [unroll]
            for(int z2=-1; z2<=1; z2++){
                float3 cell = baseCell + float3(x2, y2, z2);
                float3 cellPosition = cell + rand3dTo3d(cell);
                float3 toCell = cellPosition - value;

                float3 diffToClosestCell = abs(closestCell - cell);
                bool isClosestCell = diffToClosestCell.x + diffToClosestCell.y + diffToClosestCell.z < 0.1;
                if(!isClosestCell){
                    float3 toCenter = (toClosestCell + toCell) * 0.5;
                    float3 cellDifference = normalize(toCell - toClosestCell);
                    float edgeDistance = dot(toCenter, cellDifference);
                    minEdgeDistance = min(minEdgeDistance, edgeDistance);
                }
            }
        }
    }
    

    float random = rand3dTo1d(closestCell);
    return float3(minDistToCell, random, minEdgeDistance);
}

//TO REPEAT PARTICLE POSITION AT THE EDGES
float3 LoopPosition(inout float3 position)
{
	// x axis
	if(position.x > _BoundsDimensions.x/2 + _BoundsPosition.x)
	{
		position.x = -_BoundsDimensions.x/2 + _BoundsPosition.x;
	}
	if(position.x < -_BoundsDimensions.x/2 + _BoundsPosition.x)
	{
		position.x = _BoundsDimensions.x/2 + _BoundsPosition.x;
	}
	
	//y axis
	if(position.y > _BoundsDimensions.y/2 + _BoundsPosition.y)
	{
		position.y = -_BoundsDimensions.y/2 + _BoundsPosition.y;
	}
	
	if(position.y < -_BoundsDimensions.y/2 + _BoundsPosition.y)
	{
		position.y = _BoundsDimensions.y/2 + _BoundsPosition.y;
	}
	
	//z axis 
	if(position.z > _BoundsDimensions.z/2 + _BoundsPosition.z)
	{
		position.z = -_BoundsDimensions.z/2 + _BoundsPosition.z;
	}
	if(position.z < -_BoundsDimensions.z/2 + _BoundsPosition.z)
	{
		position.z = _BoundsDimensions.z/2 + _BoundsPosition.z;
	}
	return position;
}

//GRABS THE FLOWFIELD GRID INDEX POSITION BASED ON CURRENT POSITION WITHIN GRID
uint GrabGridIndex(float3 position)
{
    float x = floor((position.x - (_BoundsPosition.x - _BoundsDimensions.x/2)) / ((_BoundsDimensions.x / _XCellCount)));
    float y = floor((position.y - (_BoundsPosition.y - _BoundsDimensions.y/2)) / ((_BoundsDimensions.y / _YCellCount)));
    float z = floor((position.z - (_BoundsPosition.z - _BoundsDimensions.z/2)) / ((_BoundsDimensions.z / _ZCellCount)));
    
    uint flowFieldIndex = (x * _YCellCount + y) * _ZCellCount + z;
    return flowFieldIndex;
}

[numthreads(X_THREAD_COUNT,Y_THREAD_COUNT,Z_THREAD_COUNT)]
void FlowField (uint3 id : SV_DispatchThreadID)
{
    int idx = id.x;
    FlowFieldPointData flowPoint = _FlowFieldPointBuffer[idx];
    
    float3 noise = voronoiNoise(flowPoint.position);
    flowPoint.direction = normalize(noise);
    
    _FlowFieldPointBuffer[idx] = flowPoint;

}

[numthreads(X_THREAD_COUNT,Y_THREAD_COUNT,Z_THREAD_COUNT)]
void Particles (uint3 id : SV_DispatchThreadID)
{
    int idx = id.x;
    ParticleData indicator = _ParticleBuffer[idx];
    
    
    _ParticleBuffer[idx] = indicator;
}
